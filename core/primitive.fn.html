<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Function pointers, like `fn(usize) -&gt; bool`."><title>fn - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="icon" type="image/svg+xml" href="../static.files/logo.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/logo.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/logo.svg" alt="logo"></a><h2><a href="../core/index.html">core</a><span class="version">v6.9-rc1</span></h2></div><h2 class="location"><a href="#">fn</a></h2><div class="sidebar-elems"><section><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-fn(T)+-%3E+Ret">Clone</a></li><li><a href="#impl-Copy-for-fn(T)+-%3E+Ret">Copy</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-fn(T)+-%3E+Ret">RefUnwindSafe</a></li><li><a href="#impl-Send-for-fn(T)+-%3E+Ret">Send</a></li><li><a href="#impl-Sync-for-fn(T)+-%3E+Ret">Sync</a></li><li><a href="#impl-Unpin-for-fn(T)+-%3E+Ret">Unpin</a></li><li><a href="#impl-UnwindSafe-for-fn(T)+-%3E+Ret">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Debug-for-F">Debug</a></li><li><a href="#impl-Eq-for-F">Eq</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Hash-for-F">Hash</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-Ord-for-F">Ord</a></li><li><a href="#impl-PartialEq-for-F">PartialEq</a></li><li><a href="#impl-PartialOrd-for-F">PartialOrd</a></li><li><a href="#impl-Pattern%3C'a%3E-for-F">Pattern&lt;&#x27;a&gt;</a></li><li><a href="#impl-Pointer-for-F">Pointer</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate core</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../core/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <a class="primitive" href="#">fn</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Function pointers, like <code>fn(usize) -&gt; bool</code>.</p>
<p><em>See also the traits <a href="ops/trait.Fn.html" title="trait core::ops::Fn"><code>Fn</code></a>, <a href="ops/trait.FnMut.html" title="trait core::ops::FnMut"><code>FnMut</code></a>, and <a href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce"><code>FnOnce</code></a>.</em></p>
<p>Function pointers are pointers that point to <em>code</em>, not data. They can be called
just like functions. Like references, function pointers are, among other things, assumed to
not be null, so if you want to pass a function pointer over FFI and be able to accommodate null
pointers, make your type <a href="option/index.html#options-and-pointers-nullable-pointers" title="mod core::option"><code>Option&lt;fn()&gt;</code></a>
with your required signature.</p>
<h4 id="safety"><a href="#safety">Safety</a></h4>
<p>Plain function pointers are obtained by casting either plain functions, or closures that don’t
capture an environment:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>add_one(x: usize) -&gt; usize {
    x + <span class="number">1
</span>}

<span class="kw">let </span>ptr: <span class="kw">fn</span>(usize) -&gt; usize = add_one;
<span class="macro">assert_eq!</span>(ptr(<span class="number">5</span>), <span class="number">6</span>);

<span class="kw">let </span>clos: <span class="kw">fn</span>(usize) -&gt; usize = |x| x + <span class="number">5</span>;
<span class="macro">assert_eq!</span>(clos(<span class="number">5</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Afn+add_one(x:+usize)+-%3E+usize+%7B%0A++++x+%2B+1%0A%7D%0A%0Alet+ptr:+fn(usize)+-%3E+usize+=+add_one;%0Aassert_eq!(ptr(5),+6);%0A%0Alet+clos:+fn(usize)+-%3E+usize+=+%7Cx%7C+x+%2B+5;%0Aassert_eq!(clos(5),+10);%0A%7D&amp;edition=2021">Run</a></div>
<p>In addition to varying based on their signature, function pointers come in two flavors: safe
and unsafe. Plain <code>fn()</code> function pointers can only point to safe functions,
while <code>unsafe fn()</code> function pointers can point to safe or unsafe functions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>add_one(x: usize) -&gt; usize {
    x + <span class="number">1
</span>}

<span class="kw">unsafe fn </span>add_one_unsafely(x: usize) -&gt; usize {
    x + <span class="number">1
</span>}

<span class="kw">let </span>safe_ptr: <span class="kw">fn</span>(usize) -&gt; usize = add_one;

<span class="comment">//ERROR: mismatched types: expected normal fn, found unsafe fn
//let bad_ptr: fn(usize) -&gt; usize = add_one_unsafely;

</span><span class="kw">let </span>unsafe_ptr: <span class="kw">unsafe fn</span>(usize) -&gt; usize = add_one_unsafely;
<span class="kw">let </span>really_safe_ptr: <span class="kw">unsafe fn</span>(usize) -&gt; usize = add_one;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Afn+add_one(x:+usize)+-%3E+usize+%7B%0A++++x+%2B+1%0A%7D%0A%0Aunsafe+fn+add_one_unsafely(x:+usize)+-%3E+usize+%7B%0A++++x+%2B+1%0A%7D%0A%0Alet+safe_ptr:+fn(usize)+-%3E+usize+=+add_one;%0A%0A//ERROR:+mismatched+types:+expected+normal+fn,+found+unsafe+fn%0A//let+bad_ptr:+fn(usize)+-%3E+usize+=+add_one_unsafely;%0A%0Alet+unsafe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one_unsafely;%0Alet+really_safe_ptr:+unsafe+fn(usize)+-%3E+usize+=+add_one;%0A%7D&amp;edition=2021">Run</a></div>
<h4 id="abi"><a href="#abi">ABI</a></h4>
<p>On top of that, function pointers can vary based on what ABI they use. This
is achieved by adding the <code>extern</code> keyword before the type, followed by the
ABI in question. The default ABI is “Rust”, i.e., <code>fn()</code> is the exact same
type as <code>extern &quot;Rust&quot; fn()</code>. A pointer to a function with C ABI would have
type <code>extern &quot;C&quot; fn()</code>.</p>
<p><code>extern &quot;ABI&quot; { ... }</code> blocks declare functions with ABI “ABI”. The default
here is “C”, i.e., functions declared in an <code>extern {...}</code> block have “C”
ABI.</p>
<p>For more information and a list of supported ABIs, see <a href="../nomicon/ffi.html#foreign-calling-conventions">the nomicon’s
section on foreign calling conventions</a>.</p>
<h4 id="variadic-functions"><a href="#variadic-functions">Variadic functions</a></h4>
<p>Extern function declarations with the “C” or “cdecl” ABIs can also be <em>variadic</em>, allowing them
to be called with a variable number of arguments. Normal Rust functions, even those with an
<code>extern &quot;ABI&quot;</code>, cannot be variadic. For more information, see <a href="../nomicon/ffi.html#variadic-functions">the nomicon’s section on
variadic functions</a>.</p>
<h4 id="creating-function-pointers"><a href="#creating-function-pointers">Creating function pointers</a></h4>
<p>When <code>bar</code> is the name of a function, then the expression <code>bar</code> is <em>not</em> a
function pointer. Rather, it denotes a value of an unnameable type that
uniquely identifies the function <code>bar</code>. The value is zero-sized because the
type already identifies the function. This has the advantage that “calling”
the value (it implements the <code>Fn*</code> traits) does not require dynamic
dispatch.</p>
<p>This zero-sized type <em>coerces</em> to a regular function pointer. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem;

<span class="kw">fn </span>bar(x: i32) {}

<span class="kw">let </span>not_bar_ptr = bar; <span class="comment">// `not_bar_ptr` is zero-sized, uniquely identifying `bar`
</span><span class="macro">assert_eq!</span>(mem::size_of_val(<span class="kw-2">&amp;</span>not_bar_ptr), <span class="number">0</span>);

<span class="kw">let </span>bar_ptr: <span class="kw">fn</span>(i32) = not_bar_ptr; <span class="comment">// force coercion to function pointer
</span><span class="macro">assert_eq!</span>(mem::size_of_val(<span class="kw-2">&amp;</span>bar_ptr), mem::size_of::&lt;usize&gt;());

<span class="kw">let </span>footgun = <span class="kw-2">&amp;</span>bar; <span class="comment">// this is a shared reference to the zero-sized type identifying `bar`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem;%0A%0Afn+bar(x:+i32)+%7B%7D%0A%0Alet+not_bar_ptr+=+bar;+//+%60not_bar_ptr%60+is+zero-sized,+uniquely+identifying+%60bar%60%0Aassert_eq!(mem::size_of_val(%26not_bar_ptr),+0);%0A%0Alet+bar_ptr:+fn(i32)+=+not_bar_ptr;+//+force+coercion+to+function+pointer%0Aassert_eq!(mem::size_of_val(%26bar_ptr),+mem::size_of::%3Cusize%3E());%0A%0Alet+footgun+=+%26bar;+//+this+is+a+shared+reference+to+the+zero-sized+type+identifying+%60bar%60%0A%7D&amp;edition=2021">Run</a></div>
<p>The last line shows that <code>&amp;bar</code> is not a function pointer either. Rather, it
is a reference to the function-specific ZST. <code>&amp;bar</code> is basically never what you
want when <code>bar</code> is a function.</p>
<h4 id="casting-to-and-from-integers"><a href="#casting-to-and-from-integers">Casting to and from integers</a></h4>
<p>You can cast function pointers directly to integers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fnptr: <span class="kw">fn</span>(i32) -&gt; i32 = |x| x+<span class="number">2</span>;
<span class="kw">let </span>fnptr_addr = fnptr <span class="kw">as </span>usize;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0Alet+fnptr_addr+=+fnptr+as+usize;%0A%7D&amp;edition=2021">Run</a></div>
<p>However, a direct cast back is not possible. You need to use <code>transmute</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fnptr = fnptr_addr <span class="kw">as </span><span class="kw-2">*const </span>();
<span class="kw">let </span>fnptr: <span class="kw">fn</span>(i32) -&gt; i32 = <span class="kw">unsafe </span>{ std::mem::transmute(fnptr) };
<span class="macro">assert_eq!</span>(fnptr(<span class="number">40</span>), <span class="number">42</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Bcfg(not(miri))%5D+%7B+//+FIXME:+use+strict+provenance+APIs+once+they+are+stable,+then+remove+this+%60cfg%60%0Alet+fnptr:+fn(i32)+-%3E+i32+=+%7Cx%7C+x%2B2;%0Alet+fnptr_addr+=+fnptr+as+usize;%0Alet+fnptr+=+fnptr_addr+as+*const+();%0Alet+fnptr:+fn(i32)+-%3E+i32+=+unsafe+%7B+std::mem::transmute(fnptr)+%7D;%0Aassert_eq!(fnptr(40),+42);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>Crucially, we <code>as</code>-cast to a raw pointer before <code>transmute</code>ing to a function pointer.
This avoids an integer-to-pointer <code>transmute</code>, which can be problematic.
Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.</p>
<p>Note that all of this is not portable to platforms where function pointers and data pointers
have different sizes.</p>
<h4 id="abi-compatibility"><a href="#abi-compatibility">ABI compatibility</a></h4>
<p>Generally, when a function is declared with one signature and called via a function pointer with
a different signature, the two signatures must be <em>ABI-compatible</em> or else calling the function
via that function pointer is Undefined Behavior. ABI compatibility is a lot stricter than merely
having the same memory layout; for example, even if <code>i32</code> and <code>f32</code> have the same size and
alignment, they might be passed in different registers and hence not be ABI-compatible.</p>
<p>ABI compatibility as a concern only arises in code that alters the type of function pointers,
code that imports functions via <code>extern</code> blocks, and in code that combines <code>#[target_feature]</code>
with <code>extern fn</code>. Altering the type of function pointers is wildly unsafe (as in, a lot more
unsafe than even <a href="mem/fn.transmute_copy.html" title="fn core::mem::transmute_copy"><code>transmute_copy</code></a>), and should only occur in the most
exceptional circumstances. Most Rust code just imports functions via <code>use</code>. <code>#[target_feature]</code>
is also used rarely. So, most likely you do not have to worry about ABI compatibility.</p>
<p>But assuming such circumstances, what are the rules? For this section, we are only considering
the ABI of direct Rust-to-Rust calls, not linking in general – once functions are imported via
<code>extern</code> blocks, there are more things to consider that we do not go into here.</p>
<p>For two signatures to be considered <em>ABI-compatible</em>, they must use a compatible ABI string,
must take the same number of arguments, the individual argument types and the return types must
be ABI-compatible, and the target feature requirements must be met (see the subsection below for
the last point). The ABI string is declared via <code>extern &quot;ABI&quot; fn(...) -&gt; ...</code>; note that
<code>fn name(...) -&gt; ...</code> implicitly uses the <code>&quot;Rust&quot;</code> ABI string and <code>extern fn name(...) -&gt; ...</code>
implicitly uses the <code>&quot;C&quot;</code> ABI string.</p>
<p>The ABI strings are guaranteed to be compatible if they are the same, or if the caller ABI
string is <code>$X-unwind</code> and the callee ABI string is <code>$X</code>, where <code>$X</code> is one of the following:
“C”, “aapcs”, “fastcall”, “stdcall”, “system”, “sysv64”, “thiscall”, “vectorcall”, “win64”.</p>
<p>The following types are guaranteed to be ABI-compatible:</p>
<ul>
<li><code>*const T</code>, <code>*mut T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code> (specifically, only <code>Box&lt;T, Global&gt;</code>), and
<code>NonNull&lt;T&gt;</code> are all ABI-compatible with each other for all <code>T</code>. They are also ABI-compatible
with each other for <em>different</em> <code>T</code> if they have the same metadata type (<code>&lt;T as Pointee&gt;::Metadata</code>).</li>
<li><code>usize</code> is ABI-compatible with the <code>uN</code> integer type of the same size, and likewise <code>isize</code> is
ABI-compatible with the <code>iN</code> integer type of the same size.</li>
<li><code>char</code> is ABI-compatible with <code>u32</code>.</li>
<li>Any two <code>fn</code> (function pointer) types are ABI-compatible with each other if they have the same
ABI string or the ABI string only differs in a trailing <code>-unwind</code>, independent of the rest of
their signature. (This means you can pass <code>fn()</code> to a function expecting <code>fn(i32)</code>, and the
call will be valid ABI-wise. The callee receives the result of transmuting the function pointer
from <code>fn()</code> to <code>fn(i32)</code>; that transmutation is itself a well-defined operation, it’s just
almost certainly UB to later call that function pointer.)</li>
<li>Any two types with size 0 and alignment 1 are ABI-compatible.</li>
<li>A <code>repr(transparent)</code> type <code>T</code> is ABI-compatible with its unique non-trivial field, i.e., the
unique field that doesn’t have size 0 and alignment 1 (if there is such a field).</li>
<li><code>i32</code> is ABI-compatible with <code>NonZeroI32</code>, and similar for all other integer types with their
matching <code>NonZero*</code> type.</li>
<li>If <code>T</code> is guaranteed to be subject to the <a href="option/index.html#representation">null pointer
optimization</a>, then <code>T</code> and <code>Option&lt;T&gt;</code> are ABI-compatible.</li>
</ul>
<p>Furthermore, ABI compatibility satisfies the following general properties:</p>
<ul>
<li>Every type is ABI-compatible with itself.</li>
<li>If <code>T1</code> and <code>T2</code> are ABI-compatible and <code>T2</code> and <code>T3</code> are ABI-compatible, then so are <code>T1</code> and
<code>T3</code> (i.e., ABI-compatibility is transitive).</li>
<li>If <code>T1</code> and <code>T2</code> are ABI-compatible, then so are <code>T2</code> and <code>T1</code> (i.e., ABI-compatibility is
symmetric).</li>
</ul>
<p>More signatures can be ABI-compatible on specific targets, but that should not be relied upon
since it is not portable and not a stable guarantee.</p>
<p>Noteworthy cases of types <em>not</em> being ABI-compatible in general are:</p>
<ul>
<li><code>bool</code> vs <code>u8</code>, <code>i32</code> vs <code>u32</code>, <code>char</code> vs <code>i32</code>: on some targets, the calling conventions for
these types differ in terms of what they guarantee for the remaining bits in the register that
are not used by the value.</li>
<li><code>i32</code> vs <code>f32</code> are not compatible either, as has already been mentioned above.</li>
<li><code>struct Foo(u32)</code> and <code>u32</code> are not compatible (without <code>repr(transparent)</code>) since structs are
aggregate types and often passed in a different way than primitives like <code>i32</code>.</li>
</ul>
<p>Note that these rules describe when two completely known types are ABI-compatible. When
considering ABI compatibility of a type declared in another crate (including the standard
library), consider that any type that has a private field or the <code>#[non_exhaustive]</code> attribute
may change its layout as a non-breaking update unless documented otherwise – so for instance,
even if such a type is a 1-ZST or <code>repr(transparent)</code> right now, this might change with any
library version bump.</p>
<p>If the declared signature and the signature of the function pointer are ABI-compatible, then the
function call behaves as if every argument was <a href="mem/fn.transmute.html" title="fn core::mem::transmute"><code>transmute</code>d</a> from the
type in the function pointer to the type at the function declaration, and the return value is
<a href="mem/fn.transmute.html" title="fn core::mem::transmute"><code>transmute</code>d</a> from the type in the declaration to the type in the
pointer. All the usual caveats and concerns around transmutation apply; for instance, if the
function expects a <code>NonNullI32</code> and the function pointer uses the ABI-compatible type
<code>Option&lt;NonNullI32&gt;</code>, and the value used for the argument is <code>None</code>, then this call is Undefined
Behavior since transmuting <code>None::&lt;NonNullI32&gt;</code> to <code>NonNullI32</code> violates the non-null
requirement.</p>
<h5 id="requirements-concerning-target-features"><a href="#requirements-concerning-target-features">Requirements concerning target features</a></h5>
<p>Under some conditions, the signature used by the caller and the callee can be ABI-incompatible
even if the exact same ABI string and types are being used. As an example, the
<code>std::arch::x86_64::__m256</code> type has a different <code>extern &quot;C&quot;</code> ABI when the <code>avx</code> feature is
enabled vs when it is not enabled.</p>
<p>Therefore, to ensure ABI compatibility when code using different target features is combined
(such as via <code>#[target_feature]</code>), we further require that one of the following conditions is
met:</p>
<ul>
<li>The function uses the <code>&quot;Rust&quot;</code> ABI string (which is the default without <code>extern</code>).</li>
<li>Caller and callee are using the exact same set of target features. For the callee we consider
the features enabled (via <code>#[target_feature]</code> and <code>-C target-feature</code>/<code>-C target-cpu</code>) at the
declaration site; for the caller we consider the features enabled at the call site.</li>
<li>Neither any argument nor the return value involves a SIMD type (<code>#[repr(simd)]</code>) that is not
behind a pointer indirection (i.e., <code>*mut __m256</code> is fine, but <code>(i32, __m256)</code> is not).</li>
</ul>
<h4 id="trait-implementations-1"><a href="#trait-implementations-1">Trait implementations</a></h4>
<p>In this documentation the shorthand <code>fn(T₁, T₂, …, Tₙ)</code> is used to represent non-variadic
function pointers of varying length. Note that this is a convenience notation to avoid
repetitive documentation, not valid Rust syntax.</p>
<p>Due to a temporary restriction in Rust’s type system, these traits are only implemented on
functions that take 12 arguments or less, with the <code>&quot;Rust&quot;</code> and <code>&quot;C&quot;</code> ABIs. In the future, this
may change:</p>
<ul>
<li><a href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a></li>
<li><a href="cmp/trait.Eq.html" title="trait core::cmp::Eq"><code>Eq</code></a></li>
<li><a href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a></li>
<li><a href="cmp/trait.Ord.html" title="trait core::cmp::Ord"><code>Ord</code></a></li>
<li><a href="hash/trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a></li>
<li><a href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer"><code>Pointer</code></a></li>
<li><a href="fmt/derive.Debug.html" title="derive core::fmt::Debug"><code>Debug</code></a></li>
</ul>
<p>The following traits are implemented for function pointers with any number of arguments and
any ABI. These traits have implementations that are automatically generated by the compiler,
so are not limited by missing language features:</p>
<ul>
<li><a href="clone/trait.Clone.html" title="trait core::clone::Clone"><code>Clone</code></a></li>
<li><a href="marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a></li>
<li><a href="marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a></li>
<li><a href="marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a></li>
<li><a href="marker/trait.Unpin.html" title="trait core::marker::Unpin"><code>Unpin</code></a></li>
<li><a href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe"><code>UnwindSafe</code></a></li>
<li><a href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe"><code>RefUnwindSafe</code></a></li>
</ul>
<p>In addition, all <em>safe</em> function pointers implement <a href="ops/trait.Fn.html" title="trait core::ops::Fn"><code>Fn</code></a>, <a href="ops/trait.FnMut.html" title="trait core::ops::FnMut"><code>FnMut</code></a>, and <a href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce"><code>FnOnce</code></a>, because
these traits are specially known to the compiler.</p>
</div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-fn(T)+-%3E+Ret" class="impl"><a class="src rightside" href="../src/core/primitive_docs.rs.html#1679-1683">source</a><a href="#impl-Clone-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section></summary><div class="docblock"><p>This trait is implemented on function pointers with any number of arguments.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/core/primitive_docs.rs.html#1680-1682">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#169-171">source</a><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><section id="impl-Copy-for-fn(T)+-%3E+Ret" class="impl"><a class="src rightside" href="../src/core/primitive_docs.rs.html#1690-1692">source</a><a href="#impl-Copy-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section><div class="docblock"><p>This trait is implemented on function pointers with any number of arguments.</p>
</div></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-fn(T)+-%3E+Ret" class="impl"><a href="#impl-RefUnwindSafe-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section><section id="impl-Send-for-fn(T)+-%3E+Ret" class="impl"><a href="#impl-Send-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section><section id="impl-Sync-for-fn(T)+-%3E+Ret" class="impl"><a href="#impl-Sync-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section><section id="impl-Unpin-for-fn(T)+-%3E+Ret" class="impl"><a href="#impl-Unpin-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section><section id="impl-UnwindSafe-for-fn(T)+-%3E+Ret" class="impl"><a href="#impl-UnwindSafe-for-fn(T)+-%3E+Ret" class="anchor">§</a><h3 class="code-header">impl&lt;Ret, T&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.tuple.html#trait-implementations-1">fn(T₁, T₂, …, Tₙ)</a> -> Ret</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../src/core/any.rs.html#140-144">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../src/core/any.rs.html#141-143">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#208-213">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#210-212">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#216-220">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#217-219">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Debug-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#2003-2007">source</a><a href="#impl-Debug-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#2004-2006">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#763-769">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#766-768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Hash-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1989-1993">source</a><a href="#impl-Hash-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1990-1992">source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;HH&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut HH</a>)<div class="where">where
    HH: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="../src/core/hash/mod.rs.html#238-245">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(data: &amp;<a class="primitive" href="primitive.slice.html">[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#747-759">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#756-758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Ord-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1981-1986">source</a><a href="#impl-Ord-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1983-1985">source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;F</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="../src/core/cmp.rs.html#829-834">source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="../src/core/cmp.rs.html#849-854">source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="../src/core/cmp.rs.html#874-887">source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PartialEq-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1964-1969">source</a><a href="#impl-PartialEq-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1966-1968">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;F</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#242-244">source</a><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PartialOrd-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1974-1979">source</a><a href="#impl-PartialOrd-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1976-1978">source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;F</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1125-1127">source</a><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1142-1144">source</a><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1158-1160">source</a><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1175-1177">source</a><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pattern%3C'a%3E-for-F" class="impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#910-915">source</a><a href="#impl-Pattern%3C'a%3E-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;'a, F&gt; <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for F<div class="where">where
    F: <a class="trait" href="ops/trait.FnMut.html" title="trait core::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.char.html">char</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><a href="#associatedtype.Searcher" class="anchor">§</a><h4 class="code-header">type <a href="str/pattern/trait.Pattern.html#associatedtype.Searcher" class="associatedtype">Searcher</a> = <a class="struct" href="str/pattern/struct.CharPredicateSearcher.html" title="struct core::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a, F&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Associated searcher for this pattern</div></details><details class="toggle method-toggle" open><summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.into_searcher" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher" class="fn">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="str/pattern/struct.CharPredicateSearcher.html" title="struct core::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a, F&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Constructs the associated searcher from
<code>self</code> and the <code>haystack</code> to search in.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.is_contained_in" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_contained_in" class="fn">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Checks whether the pattern matches anywhere in the haystack</div></details><details class="toggle method-toggle" open><summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.is_prefix_of" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_prefix_of" class="fn">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Checks whether the pattern matches at the front of the haystack</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.strip_prefix_of" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_prefix_of" class="fn">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Removes the pattern from the front of haystack, if it matches.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.is_suffix_of" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_suffix_of" class="fn">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    <a class="struct" href="str/pattern/struct.CharPredicateSearcher.html" title="struct core::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a, F&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Checks whether the pattern matches at the back of the haystack</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#914">source</a><a href="#method.strip_suffix_of" class="anchor">§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_suffix_of" class="fn">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    <a class="struct" href="str/pattern/struct.CharPredicateSearcher.html" title="struct core::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a, F&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Removes the pattern from the back of haystack, if it matches.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointer-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1996-2000">source</a><a href="#impl-Pointer-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1997-1999">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#803-813">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#810-812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#788-798">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#795-797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Eq-for-F" class="impl"><a class="src rightside" href="../src/core/ptr/mod.rs.html#1971">source</a><a href="#impl-Eq-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for F<div class="where">where
    F: <a class="trait" href="marker/trait.FnPtr.html" title="trait core::marker::FnPtr">FnPtr</a>,</div></h3></section></div></section></div></main></body></html>